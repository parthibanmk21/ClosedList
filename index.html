<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClosedList</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      min-height: 100vh;
      min-width: 0;
    }

    .container {
      display: flex;
      gap: 16px;
      padding: 20px;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
    }

    .flex-item {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px;
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
      /* max-width: 480px; */
    }

    .flex-item-3 {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px;
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      max-width: 300px;
    }

    .flex-item-4 {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px 8px;
      flex: 1 1 320px;
      display: flex;
      gap: 8px;
      flex-direction: column;
      min-height: 0;
      max-width: 40px;
    }

    .flex-arrow {
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      transition: background 0.18s, box-shadow 0.18s;
      border-radius: 8px;
      padding: 4px;
    }
    .flex-arrow.selected {
      background: #dddedf;
      box-shadow: 0 2px 8px rgba(26, 79, 160, 0.08);
    }
    .flex-arrow:hover {
      background: #dddedf;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
    }
    .flex-arrow svg {
      transition: fill 0.18s, transform 0.2s;
    }
    
    .flex-item-3 h3 {
      margin: 0 0 0.5em 0;
      font-size: 1.1em;
      color: #333;
      font-weight: 600;
    }

    .flex-item h3 {
      margin: 0 0 0.5em 0;
      font-size: 1.1em;
      color: #333;
      font-weight: 600;
    }

    .input-field {
      /* width: 100%; */
      font-size: 1em;
      background: #eeeeee;
      border: none;
      border: 2px solid #eeeeee;
      border-radius: 8px;
      padding: 8px;
      outline: none;
      transition: border-color 0.18s;
      color: #222;
      margin-bottom: 0.2em;
      box-shadow: none;
      resize: none;
      min-height: 120px;
      max-height: 100%;
      flex: 1 1 auto;
      overflow-y: auto;
      font-family: inherit;
      line-height: 1.5em;
      white-space: pre-wrap;
      word-break: break-word;
      letter-spacing: 0.03em;
    }

    .input-field:focus {
      border: 2px solid #242424;
      border-radius: 8px;
      background: #fafafa;
    }

    .input-field:disabled {
      background: #ededed;
      color: #b2b2b2;
      border-bottom: 2px solid #efefef;
    }

    .search-field {
      width: 100%;
      font-size: 1em;
      background: #fff;
      border: 2px solid #c8c8c8;
      border-radius: 8px;
      padding: 0.7em 0.9em 0.7em 0.9em;
      outline: none;
      transition: border-color 0.18s, box-shadow 0.18s;
      color: #222;
      margin-bottom: 0.5em;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
      resize: none;
      min-height: 0;
      flex: 0 0 auto;
      font-family: inherit;
      box-sizing: border-box;
    }

    .search-field:hover {
      border: 2px solid #222;
    }

    .search-field:focus {
      border: 2px solid #242424;
      box-shadow: 0 0 0 2px #e3e3e3;
      background: #ffffff;
    }

    .search-field:disabled {
      background: #909090;
      color: #b2b2b2;
      border: 2px solid #efefef;
      box-shadow: none;
    }

    .selected-field[readonly] {
      /* width: 100%; */
      font-size: 1em;
      background: #f7f7f7;
      color: #222;
      border: 2px solid #e3e3e3;
      border-radius: 6px;
      padding: 0.7em 0.9em 0.7em 0.9em;
      outline: none;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
      margin-bottom: 0.2em;
      font-family: inherit;
      transition: border-color 0.18s, box-shadow 0.18s;
    }

    .selected-field[readonly]:focus {
      border: 2px solid #242424;
      box-shadow: 0 0 0 2px #e3e3e3;
      background: #f7f7f7;
    }

    .selected-field[readonly]:disabled {
      background: #ededed;
      color: #b2b2b2;
      border: 2px solid #efefef;
      box-shadow: none;
    }

    .formatted-html {
      background: #f0f0f0;
      border-radius: 6px;
      padding: 1em;
      font-family: 'Fira Mono', monospace;
      white-space: pre-wrap;
      word-break: break-word;
      flex: 1 1 0;
      min-height: 0;
      overflow: auto;
      font-family: inherit;
      line-height: 1.5em;
      font-size: 1em;
      margin-bottom: 0.2em;
      letter-spacing: 0.03em;
    }

    .highlight {
      background: #ffe066;
      color: #222;
      border-radius: 3px;
      padding: 0 2px;
    }

    .checkbox-list {
      border: 2px solid #c8c8c8;
      border-radius: 8px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      margin-bottom: 0.5em;
      /* max-height: 32vh; */
    }

    .checkbox-item {
      display: flex;
      background: #f7f7f7;
      align-items: center;
      gap: 0.7em;
      font-size: 1em;
      border-radius: 4px;
      padding: 0.5em 0.7em;
      cursor: pointer;
      transition: background 0.15s, color 0.15s, border 0.15s;
      min-width: 0;
    }

    .checkbox-item.valid {
      background: #e8f5e8;
      border-left: 3px solid #4caf50;
    }

    .checkbox-item.invalid {
      background: #ffeaea;
      border-left: 3px solid #f44336;
    }

    .checkbox-item input[type="checkbox"] {
      cursor: pointer;
      accent-color: #575757;
      width: 1.1em;
      height: 1.1em;
      margin: 0;
    }

    .checkbox-item:hover {
      background: #e6e6e6;
      color: #292929;
    }

    .checkbox-item.valid:hover {
      background: #d4f0d4;
    }

    .checkbox-item.invalid:hover {
      background: #ffd6d6;
    }

    .checkbox-item.selected {
      background: #d0d0d0;
      color: #272727;
    }

    .checkbox-item.valid.selected {
      background: #c8e6c9;
      color: #272727;
    }

    .checkbox-item.invalid.selected {
      background: #ffcdd2;
      color: #272727;
    }

    .copy-btn {
      width: 100%;
      margin-top: 0.2em;
      padding: 0.7em 1.2em;
      border: none;
      border-radius: 4px;
      background: #1a4fa0;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s;
      align-self: flex-end;
    }

    .copy-btn:hover {
      background: #163e7a;
    }

    /* @media (max-width: 900px) {
      .container {
        flex-direction: column;
        gap: 3vw;
        padding: 20px;
        height: auto;
        min-height: 100vh;
      }
      .flex-item {
        max-width: 100vw;
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }
    @media (max-width: 600px) {
      .container {
        padding: 2vw 1vw;
        gap: 2vw;
      }
      .flex-item {
        padding: 4vw 2vw;
      }
      .formatted-html {
        font-size: 0.95em;
      }
      .checkbox-item {
        font-size: 0.97em;
        padding: 0.4em 0.5em;
      }
      .copy-btn {
        font-size: 0.97em;
        padding: 0.6em 1em;
      }
    } */
    /* Syntax highlighting classes */
    .hl-tag { color: #1a4fa0; font-weight: bold; }
    .hl-attr { color: #b76b00; }
    .hl-value { color: #008c6e; }
    .hl-comment { color: #909090; font-style: italic; }

    /* Thumbnails row for image popup */
    #thumbsRow {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      /* padding-top: 8px; */
      width: 100%;
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      padding: 8px;
      scrollbar-width: thin;
      scrollbar-color: #bbb #eee;
      box-sizing: border-box;
      background: #eaeaea;
    }
    #thumbsRow img {
      flex-shrink: 0;
      height: 40px;
      width: auto;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.12);
      cursor: pointer;
      border: 2px solid transparent;
      background: #fff;
      transition: border 0.15s;
    }

    /* Image preview zoom on hover */
    #imgPreview {
      transition: transform 0.1ase;
      cursor: grab;
      user-select: none;
    }
    #imgPreview.zoomed {
      cursor: grabbing;
    }
    #imgPreview.zoomed:hover {
      cursor: grabbing;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- First Div: Input Field -->
    <div class="flex-item">
      <h3>Enter yor base data here</h3>
      <textarea class="input-field" id="mainInput" rows="7" placeholder="Type values here..."></textarea>
    </div>
    <!-- Second Div: Formatted HTML Display -->
    <div class="flex-item">
      <h3>Formatted HTML Output:</h3>
      <div class="formatted-html" id="formattedOutput"></div>
      <div id="sdldCount" style="margin-top: 10px; font-size: 1em; color: #333;"></div>
    </div>
    <!-- Third Div: Search/Highlight/Checkboxes -->
    <div class="flex-item-3" id="flexItem3">
      <h3>Enter the text to highlight</h3>
      <div style="position: relative; display: flex; align-items: center; justify-content: center;">
        <input class="search-field" id="highlightInput" type="text" placeholder="Type to highlight..." style="padding-right: 2.2em;" />
        <button id="clearHighlightBtn" type="button" style="position: absolute; right: 0.5em; background: none; border: none; font-size: 1.2em; color: #888; cursor: pointer; height: 55%; display: flex; align-items: flex-star; justify-content: center;">&times;</button>
      </div>
      <div class="checkbox-list" id="checkboxList"></div>
      <input class="selected-field" id="selectedValues" type="text" placeholder="Selected values..." readonly />
      <button class="copy-btn" id="copyBtn" type="button">Copy</button>
    </div>
    <div class="flex-item-4">
      <div class="flex-arrow" id="flexArrow">
        <svg id="arrowIcon" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#4f4f4f" viewBox="0 0 24 24"
          style="transition: transform 0.2s; transform: rotate(180deg);">
          <path fill-rule="evenodd"
            d="M10 4H4c-1.10457 0-2 .89543-2 2v12c0 1.1046.89543 2 2 2h6V4ZM7.79283 9.29289c.39053.39053.39053 1.02371 0 1.41421L6.5 11.9999l1.29283 1.2929c.39053.3905.39053 1.0237 0 1.4142-.39052.3905-1.02368.3905-1.41421 0l-1.99994-2c-.39052-.3905-.39052-1.0236 0-1.4142l1.99994-1.99991c.39053-.39052 1.02369-.39052 1.41421 0Z"
            clip-rule="evenodd" />
          <path d="M12 20h8c1.1046 0 2-.8954 2-2V6c0-1.10457-.8954-2-2-2h-8v16Z" />
        </svg>
      </div>
      <div class="flex-arrow" id="flexArrow">
        <svg id="imgPopup" class="w-6 h-6" aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#4f4f4f" viewBox="0 0 24 24" >
          <path fill-rule="evenodd" d="M13 10a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H14a1 1 0 0 1-1-1Z" clip-rule="evenodd" />
          <path fill-rule="evenodd"
            d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12c0 .556-.227 1.06-.593 1.422A.999.999 0 0 1 20.5 20H4a2.002 2.002 0 0 1-2-2V6Zm6.892 12 3.833-5.356-3.99-4.322a1 1 0 0 0-1.549.097L4 12.879V6h16v9.95l-3.257-3.619a1 1 0 0 0-1.557.088L11.2 18H8.892Z"
            clip-rule="evenodd" />
        </svg>
      </div>
    </div>
    <!-- Image Popup -->
    <div id="imagePopupBg"
      style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.7); z-index:1000; justify-content:center; align-items:center;">
      <div id="imagePopupContent" style="background:#fff; border-radius:12px; margin:16px; width:calc(95vw - 32px); height:calc(95vh - 32px); display:flex; flex-direction:row; overflow:hidden;">
        <div
          style="flex:0 0 30%; padding:24px 12px 24px 24px; display:flex; flex-direction:column; justify-content:center; background:#f7f7f7;">
          <label for='imgLinkInput' style='font-size:1em; margin-bottom:8px; color:#222;'>Image Link(s)</label>
          <textarea id="imgLinkInput" placeholder="Paste image link(s), separated by commas..."
            style="width:100%; height:100%; min-height:0; resize:none; font-size:1em; padding:8px; border-radius:8px; border:1px solid #ccc; box-sizing:border-box; flex:1 1 auto;"></textarea>
          <button id="cleanLinksBtn" type="button" style="margin-top:8px; padding:7px 16px; border-radius:6px; border:none; background:#1a4fa0; color:#fff; font-size:1em; cursor:pointer;">Clean Links</button>
        </div>
        <div style="flex:1 1 70%; display:flex; flex-direction:column; background:#eaeaea; position:relative; min-width:0; min-height:0; overflow:hidden;">
          <div style="flex:1 1 auto; padding:8px; display:flex; align-items:center; justify-content:center; min-height:0; min-width:0; position:relative;">
            <button id="carouselPrev" style="position:absolute; left:8px; z-index:2; background:rgba(0,0,0,0.3); border:none; border-radius:50%; width:36px; height:36px; display:none; align-items:center; justify-content:center; cursor:pointer; color:#fff; font-size:1.5em;">&#8592;</button>
            <img id="imgPreview" src="" alt="Preview"
              style="max-width:100%; max-height:100%; border-radius:8px; object-fit:contain; background:#fff; display:block; margin:auto;" />
            <button id="carouselNext" style="position:absolute; right:8px; z-index:2; background:rgba(0,0,0,0.3); border:none; border-radius:50%; width:36px; height:36px; display:none; align-items:center; justify-content:center; cursor:pointer; color:#fff; font-size:1.5em;">&#8594;</button>
          </div>
          <div id="thumbsRow"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Helper: Parse input into array
    function parseInput(input) {
      return input
        .split(/\n/)
        .map(v => v.trim())
        .filter(v => v.length > 0);
    }

    // Helper: Escape HTML
    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, function (tag) {
        const chars = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        };
        return chars[tag] || tag;
      });
    }

    // Helper: Extract text nodes from HTML
    function extractTextNodesFromHTML(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      const textNodes = [];
      function traverse(node) {
        if (node.nodeType === 3) { // Text node
          textNodes.push(node.textContent.trim());
        } else if (node.nodeType === 1) { // Element node
          for (let child of node.childNodes) {
            traverse(child);
          }
        }
      }
      traverse(tempDiv);
      return textNodes;
    }

    // DOM Elements
    const mainInput = document.getElementById('mainInput');
    const formattedOutput = document.getElementById('formattedOutput');
    const highlightInput = document.getElementById('highlightInput');
    const checkboxList = document.getElementById('checkboxList');
    const selectedValues = document.getElementById('selectedValues');
    const copyBtn = document.getElementById('copyBtn');

    let values = [];
    let highlightText = '';
    let checkedSet = new Set();
    // State for single selected (for highlight)
    let singleSelected = '';

    // Render formatted HTML output and SD/LD counts
    function renderFormatted() {
      // If a value is selected in the checkbox-list, highlight it in the formatted-html
      let selectedHighlight = singleSelected;
      formattedOutput.innerHTML = values.map(val => {
        // If selectedHighlight is set, highlight it in the HTML (even if it's an HTML tag)
        if (selectedHighlight && val.toLowerCase().includes(selectedHighlight.toLowerCase())) {
          // Highlight all matches (but do not escape HTML, render as real HTML)
          const regex = new RegExp(`(${selectedHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          // Walk HTML nodes and highlight
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = val;
          function highlightNode(node) {
            if (node.nodeType === 3) { // Text node
              return node.nodeValue.replace(regex, '<span class="highlight">$1</span>');
            } else if (node.nodeType === 1) { // Element node
              let html = `<${node.tagName.toLowerCase()}`;
              for (let attr of node.attributes) {
                html += ` ${attr.name}="${attr.value}"`;
              }
              html += '>';
              for (let child of node.childNodes) {
                html += highlightNode(child);
              }
              html += `</${node.tagName.toLowerCase()}>`;
              return html;
            }
            return '';
          }
          let highlighted = '';
          for (let child of tempDiv.childNodes) {
            highlighted += highlightNode(child);
          }
          return `<div>${highlighted}</div>`;
        } else {
          // Render as real HTML
          return `<div>${val}</div>`;
        }
      }).join('');

      // SD/LD count logic
      const sdldDiv = document.getElementById('sdldCount');
      // Join all values as HTML for parsing
      const htmlString = values.join('\n');
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlString;
      // SD: count words in all <p> tags
      let sdCount = 0;
      const pTags = tempDiv.querySelectorAll('p');
      pTags.forEach(p => {
        // Count words in this <p>
        const words = p.textContent.trim().split(/\s+/).filter(Boolean);
        sdCount += words.length;
      });
      // LD: count <li> in all <ul>
      let ldCount = 0;
      const ulTags = tempDiv.querySelectorAll('ul');
      ulTags.forEach(ul => {
        ldCount += ul.querySelectorAll('li').length;
      });
      // SD color and fail
      let sdColor = sdCount < 55 ? 'red' : '#00ca00';
      let sdFail = sdCount < 55 ? ' <span style="color:red">(Fail)</span>' : ' <span style="color:#00ca00">(Pass)</span>';
      // LD color and fail
      let ldColor = ldCount < 3 ? 'red' : '#00ca00';
      let ldFail = ldCount < 3 ? ' <span style="color:red">(Fail)</span>' : ' <span style="color:#00ca00">(Pass)</span>';
      sdldDiv.innerHTML = `SD count: <span style="color:${sdColor}">${sdCount}</span>${sdFail}, LD count: <span style="color:${ldColor}">${ldCount}</span>${ldFail}`;
    }

    // Render checkbox list
    function renderCheckboxes() {
      // Show search terms from search-field in checkbox list
      let allCheckboxValues = [];
      if (highlightText.trim() !== '') {
        // Split search field by comma, colon, semicolon, pipe, trim, and filter non-empty
        allCheckboxValues = highlightText.split(/[,:;|]/).map(v => v.trim()).filter(v => v.length > 0);
      }
      // Prepare array with validity and count
      let checkboxData = allCheckboxValues.map((val, idx) => {
        const count = values.reduce((acc, v) => acc + (v.toLowerCase().includes(val.toLowerCase()) ? 1 : 0), 0);
        const isValid = count > 0;
        return { val, idx, checked: checkedSet.has(val), selected: singleSelected === val, isValid, count };
      });
      // Sort: valid first, then invalid
      checkboxData.sort((a, b) => {
        if (a.isValid === b.isValid) return 0;
        return a.isValid ? -1 : 1;
      });
      // Render
      checkboxList.innerHTML = checkboxData.map(item => {
        const checked = item.checked ? 'checked' : '';
        const selected = item.selected ? 'selected' : '';
        const validationClass = item.isValid ? 'valid' : 'invalid';
        // Show count next to span
        return `<div class="checkbox-item ${selected} ${validationClass}" data-value="${escapeHtml(item.val)}"><input type="checkbox" data-idx="${item.idx}" value="${escapeHtml(item.val)}" ${checked}><span>${escapeHtml(item.val)} <b>(${item.count})</b></span></div>`;
      }).join('');
    }

    // Update selected values field
    function updateSelectedField() {
      // Use pipeline separator instead of comma
      selectedValues.value = Array.from(checkedSet).join('|');
    }

    // Event: Main input change
    mainInput.addEventListener('input', () => {
      values = parseInput(mainInput.value);
      // Remove unchecked values from checkedSet
      checkedSet = new Set(values.filter(v => checkedSet.has(v)));
      renderFormatted();
      renderCheckboxes();
      updateSelectedField();
      singleSelected = '';
    });

    // Event: Highlight input change
    highlightInput.addEventListener('input', () => {
      highlightText = highlightInput.value;
      renderFormatted();
      renderCheckboxes(); // Update checkbox list when search text changes
      singleSelected = '';
    });

    // Event: Checkbox click (multi-select)
    checkboxList.addEventListener('click', (e) => {
      if (e.target && e.target.type === 'checkbox') {
        const input = e.target;
        const val = input.value;
        if (checkedSet.has(val)) {
          checkedSet.delete(val);
        } else {
          checkedSet.add(val);
        }
        renderCheckboxes();
        updateSelectedField();
        renderFormatted(); // Update formatted-html with highlight
      }
    });

    // Event: Checkbox-item click (single select for highlight)
    checkboxList.addEventListener('click', (e) => {
      // Only trigger if not clicking the checkbox itself
      if (e.target && e.target.type === 'checkbox') return;
      const item = e.target.closest('.checkbox-item');
      if (!item) return;
      const val = item.getAttribute('data-value');
      if (singleSelected === val) {
        singleSelected = '';
      } else {
        singleSelected = val;
      }
      renderCheckboxes();
      renderFormatted();
    });

    // Copy button logic
    copyBtn.addEventListener('click', () => {
      if (selectedValues.value) {
        navigator.clipboard.writeText(selectedValues.value);
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyBtn.textContent = 'Copy';
        }, 1200);
      }
    });

    // Arrow toggle logic
    const flexItem3 = document.getElementById('flexItem3');
    const flexArrow = document.getElementById('flexArrow');
    const arrowIcon = document.getElementById('arrowIcon');
    let flexItem3Visible = true;
    flexArrow.addEventListener('click', () => {
      flexItem3Visible = !flexItem3Visible;
      if (flexItem3Visible) {
        flexItem3.style.display = '';
        arrowIcon.style.transform = 'rotate(180deg)'; // Left
        flexArrow.classList.add('selected');
      } else {
        flexItem3.style.display = 'none';
        arrowIcon.style.transform = 'rotate(0deg)'; // Right
        flexArrow.classList.remove('selected');
      }
    });
    // Set default selected state
    flexArrow.classList.add('selected');

    // Image Popup logic
    const imgPopup = document.getElementById('imgPopup');
    const imagePopupBg = document.getElementById('imagePopupBg');
    const imgLinkInput = document.getElementById('imgLinkInput');
    const imgPreview = document.getElementById('imgPreview');
    const carouselPrev = document.getElementById('carouselPrev');
    const carouselNext = document.getElementById('carouselNext');
    const thumbsRow = document.getElementById('thumbsRow');
    let imageLinks = [];
    let currentImgIdx = 0;
    let popupOpen = false;

    // Function to toggle image popup
    function toggleImagePopup() {
      if (!popupOpen) {
        imagePopupBg.style.display = 'flex';
        popupOpen = true;
        // imgLinkInput.focus(); // Removed to prevent auto-focus and accidental 'e' input
        // Restore the links if they exist
        if (imageLinks.length > 0) {
          imgLinkInput.value = imageLinks.join(', ');
          updateImagePreview();
        }
      } else {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    }

    imgPopup.style.cursor = 'pointer';
    imgPopup.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent any parent logic
      toggleImagePopup();
    });

    // Keyboard shortcuts for arrowIcon (Q) and imgPopup (E)
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === 'q' || e.key === 'Q') {
        flexArrow.click();
      }
      if (e.key === 'e' || e.key === 'E') {
        toggleImagePopup();
      }
    });

    // Add clear button logic for highlight input
    const clearHighlightBtn = document.getElementById('clearHighlightBtn');
    clearHighlightBtn.addEventListener('click', () => {
      highlightInput.value = '';
      highlightText = '';
      renderFormatted();
      renderCheckboxes();
      singleSelected = '';
      checkedSet.clear();
      updateSelectedField();
    });

    // Image preview pan and zoom functionality
    let isZoomed = false;
    let isDragging = false;
    let startX, startY, translateX = 0, translateY = 0, scale = 1;

    imgPreview.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      scale = Math.max(0.5, Math.min(3, scale * delta));
      updateImageTransform();
    });

    imgPreview.addEventListener('mousedown', (e) => {
      if (scale > 1) {
        isDragging = true;
        imgPreview.classList.add('zoomed');
        startX = e.clientX - translateX;
        startY = e.clientY - translateY;
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging && scale > 1) {
        translateX = e.clientX - startX;
        translateY = e.clientY - startY;
        updateImageTransform();
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      imgPreview.classList.remove('zoomed');
    });

    function updateImageTransform() {
      imgPreview.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    // Reset zoom when changing images
    function resetImageZoom() {
      scale = 1;
      translateX = 0;
      translateY = 0;
      updateImageTransform();
    }

    // Live update image preview and carousel
    function updateImagePreview() {
      // Split by comma, trim, filter empty
      imageLinks = imgLinkInput.value.split(',').map(v => v.trim()).filter(v => v.length > 0);
      if (imageLinks.length === 0) {
        imgPreview.src = '';
        carouselPrev.style.display = 'none';
        carouselNext.style.display = 'none';
        thumbsRow.innerHTML = '';
        resetImageZoom();
        return;
      }
      if (currentImgIdx >= imageLinks.length) currentImgIdx = 0;
      imgPreview.src = imageLinks[currentImgIdx];
      resetImageZoom();
      if (imageLinks.length > 1) {
        carouselPrev.style.display = 'flex';
        carouselNext.style.display = 'flex';
      } else {
        carouselPrev.style.display = 'none';
        carouselNext.style.display = 'none';
      }
      // Render all thumbnails
      thumbsRow.innerHTML = imageLinks.map((src, idx) =>
        `<img src="${src}" data-idx="${idx}" style="height:40px; width:auto; border-radius:6px; box-shadow:0 1px 4px rgba(0,0,0,0.12); cursor:pointer; border:2px solid ${idx === currentImgIdx ? '#1a4fa0' : 'transparent'}; background:#fff; transition:border 0.15s;">`
      ).join('');
    }

    // Thumbnail click logic
    thumbsRow.addEventListener('click', (e) => {
      if (e.target && e.target.tagName === 'IMG' && e.target.hasAttribute('data-idx')) {
        const idx = parseInt(e.target.getAttribute('data-idx'));
        if (!isNaN(idx)) {
          currentImgIdx = idx;
          updateImagePreview();
        }
      }
    });

    imgLinkInput.addEventListener('input', () => {
      currentImgIdx = 0;
      updateImagePreview();
    });

    carouselPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      if (imageLinks.length > 1) {
        currentImgIdx = (currentImgIdx - 1 + imageLinks.length) % imageLinks.length;
        updateImagePreview();
      }
    });
    carouselNext.addEventListener('click', (e) => {
      e.stopPropagation();
      if (imageLinks.length > 1) {
        currentImgIdx = (currentImgIdx + 1) % imageLinks.length;
        updateImagePreview();
      }
    });

    // Close popup on bg click (not content)
    imagePopupBg.addEventListener('click', (e) => {
      if (e.target === imagePopupBg) {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    });

    // Close popup on ESC
    document.addEventListener('keydown', (e) => {
      if (popupOpen && e.key === 'Escape') {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    });

    // Keyboard navigation for image popup carousel
    document.addEventListener('keydown', (e) => {
      if (popupOpen && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        if (imageLinks.length > 1) {
          if (e.key === 'ArrowLeft') {
            currentImgIdx = (currentImgIdx - 1 + imageLinks.length) % imageLinks.length;
            updateImagePreview();
          } else if (e.key === 'ArrowRight') {
            currentImgIdx = (currentImgIdx + 1) % imageLinks.length;
            updateImagePreview();
          }
        }
      }
    });

    // Clean links button logic
    const cleanLinksBtn = document.getElementById('cleanLinksBtn');
    cleanLinksBtn.addEventListener('click', () => {
      // Split by comma, extract http(s)...jpg|jpeg|png
      const cleaned = imgLinkInput.value.split(',').map(link => {
        const match = link.match(/https?[^\s,]*?\.(jpg|jpeg|png)/i);
        return match ? match[0] : '';
      }).filter(Boolean);
      imgLinkInput.value = cleaned.join(', ');
      updateImagePreview();
    });

    // Initial render
    renderFormatted();
    renderCheckboxes();
    updateSelectedField();
    updateImagePreview();

    // Escape key handler for input-field
    mainInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // Clear selection in contenteditable
        window.getSelection().removeAllRanges();
        mainInput.blur();
      }
    });
  </script>
</body>

</html>

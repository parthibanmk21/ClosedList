<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClosedList</title>
  <!-- Add Prism.js CSS for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      min-height: 100vh;
      min-width: 0;
    }

    .container {
      display: flex;
      gap: 16px;
      padding: 20px;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
    }

    p {
      margin-top: 0px;
    }

    .flex-item {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px;
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
      /* max-width: 480px; */
    }

    .flex-item-3 {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px;
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      max-width: 300px;
    }

    .flex-item-4 {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
      padding: 16px 8px;
      flex: 1 1 320px;
      display: flex;
      gap: 8px;
      flex-direction: column;
      min-height: 0;
      max-width: 40px;
      position: relative;
    }
    .flex-arrow {
      position: relative;
    }
    .flex-arrow .leftool-label {
      display: none;
      position: absolute;
      right: 48px;
      left: auto;
      top: 50%;
      transform: translateY(-50%);
      background: #3d3d3d;
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 0.95em;
      white-space: nowrap;
      z-index: 10;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .flex-arrow:hover .leftool-label {
      display: block;
    }

    .flex-arrow {
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      transition: background 0.18s, box-shadow 0.18s;
      border-radius: 8px;
      padding: 4px;
    }

    .flex-arrow.selected {
      background: #dddedf;
      box-shadow: 0 2px 8px rgba(26, 79, 160, 0.08);
    }

    .flex-arrow:hover {
      background: #dddedf;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.10);
    }

    .flex-arrow svg {
      transition: fill 0.18s, transform 0.2s;
    }

    .flex-item-3 h3 {
      margin: 0 0 0.5em 0;
      font-size: 1.1em;
      color: #333;
      font-weight: 600;
    }

    .flex-item h3 {
      margin: 0 0 0.5em 0;
      font-size: 1.1em;
      color: #333;
      font-weight: 600;
    }

    .input-field {
      /* width: 100%; */
      font-size: 1em;
      background: #eeeeee;
      border: none;
      border: 2px solid #eeeeee;
      border-radius: 8px;
      padding: 8px;
      outline: none;
      transition: border-color 0.18s;
      color: #222;
      margin-bottom: 0.2em;
      box-shadow: none;
      resize: none;
      min-height: 120px;
      max-height: 100%;
      flex: 1 1 auto;
      overflow-y: auto;
      font-family: inherit;
      line-height: 1.5em;
      white-space: pre-wrap;
      word-break: break-word;
      letter-spacing: 0.03em;
    }

    .input-field:focus {
      border: 2px solid #242424;
      border-radius: 8px;
      background: #fafafa;
    }

    .input-field:disabled {
      background: #ededed;
      color: #b2b2b2;
      border-bottom: 2px solid #efefef;
    }

    .search-field {
      width: 100%;
      font-size: 1em;
      background: #fff;
      border: 2px solid #c8c8c8;
      border-radius: 8px;
      padding: 0.7em 0.9em 0.7em 0.9em;
      outline: none;
      transition: border-color 0.18s, box-shadow 0.18s;
      color: #222;
      margin-bottom: 0.5em;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
      resize: none;
      min-height: 0;
      flex: 0 0 auto;
      font-family: inherit;
      box-sizing: border-box;
    }

    .search-field:hover {
      border: 2px solid #222;
    }

    .search-field:focus {
      border: 2px solid #242424;
      box-shadow: 0 0 0 2px #e3e3e3;
      background: #ffffff;
    }

    .search-field:disabled {
      background: #909090;
      color: #b2b2b2;
      border: 2px solid #efefef;
      box-shadow: none;
    }

    .selected-field[readonly] {
      /* width: 100%; */
      font-size: 1em;
      background: #f7f7f7;
      color: #222;
      border: 2px solid #e3e3e3;
      border-radius: 6px;
      padding: 0.7em 0.9em 0.7em 0.9em;
      outline: none;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
      margin-bottom: 0.2em;
      font-family: inherit;
      transition: border-color 0.18s, box-shadow 0.18s;
    }

    .selected-field[readonly]:focus {
      border: 2px solid #242424;
      box-shadow: 0 0 0 2px #e3e3e3;
      background: #f7f7f7;
    }

    .selected-field[readonly]:disabled {
      background: #ededed;
      color: #b2b2b2;
      border: 2px solid #efefef;
      box-shadow: none;
    }

    .formatted-html {
      background: #f0f0f0;
      border-radius: 6px;
      font-family: Georgia, Times, 'Times New Roman', serif;
      white-space: pre-wrap;
      word-break: break-word;
      flex: 1 1 0;
      min-height: 0;
      overflow: auto;
      line-height: 1.5em;
      font-size: 1em;
      padding: 8px;
      margin-bottom: 0.2em;
      letter-spacing: 0.03em;
    }

    .highlight {
      background: #ffe066;
      color: #222;
      border-radius: 3px;
      padding: 0 2px;
    }

    .highlight.focused {
      background: #ffb74d;
      color: #222;
      border-radius: 3px;
      padding: 0 2px;
      box-shadow: 0 0 0 2px #ff9800;
    }

    .checkbox-list {
      border: 2px solid #c8c8c8;
      border-radius: 8px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      margin-bottom: 0.5em;
      /* max-height: 32vh; */
    }

    .checkbox-item {
      display: flex;
      background: #f7f7f7;
      align-items: center;
      font-size: 1em;
      border-radius: 4px;
      /* padding: 0.5em 0.7em; */
      cursor: pointer;
      transition: background 0.15s, color 0.15s, border 0.15s;
      min-width: 0;
    }

    .checkbox-item.valid {
      background: #e8f5e8;
      border-left: 3px solid #4caf50;
    }

    .checkbox-item.invalid {
      background: #ffeaea;
      border-left: 3px solid #f44336;
    }

    .checkbox-item input[type="checkbox"] {
      cursor: pointer;
      accent-color: #575757;
      width: 1.1em;
      height: 1.1em;
      margin: 0;
    }

    .checkbox-item:hover {
      background: #e6e6e6;
      color: #292929;
    }

    .checkbox-item.valid:hover {
      background: #d4f0d4;
    }

    .checkbox-item.invalid:hover {
      background: #ffd6d6;
    }

    .checkbox-item.selected {
      background: #d0d0d0;
      color: #272727;
    }

    .checkbox-item.valid.selected {
      background: #c8e6c9;
      color: #272727;
    }

    .checkbox-item.invalid.selected {
      background: #ffcdd2;
      color: #272727;
    }

    .copy-btn {
      width: 100%;
      margin-top: 0.2em;
      padding: 0.7em 1.2em;
      border: none;
      border-radius: 4px;
      background: #1a4fa0;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s;
      align-self: flex-end;
    }

    .copy-btn:hover {
      background: #163e7a;
    }

    /* @media (max-width: 900px) {
      .container {
        flex-direction: column;
        gap: 3vw;
        padding: 20px;
        height: auto;
        min-height: 100vh;
      }
      .flex-item {
        max-width: 100vw;
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }
    @media (max-width: 600px) {
      .container {
        padding: 2vw 1vw;
        gap: 2vw;
      }
      .flex-item {
        padding: 4vw 2vw;
      }
      .formatted-html {
        font-size: 0.95em;
      }
      .checkbox-item {
        font-size: 0.97em;
        padding: 0.4em 0.5em;
      }
      .copy-btn {
        font-size: 0.97em;
        padding: 0.6em 1em;
      }
    } */
    /* Syntax highlighting classes */
    .hl-tag {
      color: #1a4fa0;
      font-weight: bold;
    }

    .hl-attr {
      color: #b76b00;
    }

    .hl-value {
      color: #008c6e;
    }

    .hl-comment {
      color: #909090;
      font-style: italic;
    }

    /* Thumbnails row for image popup */
    #thumbsRow {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      /* padding-top: 8px; */
      width: 100%;
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      padding: 8px;
      scrollbar-width: thin;
      scrollbar-color: #bbb #eee;
      box-sizing: border-box;
      background: #eaeaea;
    }

    #thumbsRow img {
      flex-shrink: 0;
      height: 40px;
      width: auto;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
      cursor: pointer;
      border: 2px solid transparent;
      background: #fff;
      transition: border 0.15s;
    }

    /* Image preview zoom on hover */
    #imgPreview {
      transition: transform 0.3s ease;
      cursor: zoom-in;
      user-select: none;
      transform-origin: center;
    }

    #imgPreview:hover {
      transform: scale(1.5);
      cursor: zoom-out;
    }

    #imgPreview.zoomed {
      cursor: grab;
    }

    #imgPreview.zoomed:hover {
      cursor: grabbing;
    }

    /* Checkbox item icons */
    .checkbox-item {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .checkbox-item .selection-area {
      display: flex;
      align-items: center;
      gap: 0.7em;
      padding: 8px;
      flex: 1;
      cursor: pointer;
    }

    .checkbox-item .icon-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px;
      height: 24px;
      cursor: pointer;
    }

    .checkbox-item.valid .icon-container svg {
      fill: #4caf50;
      width: 20px;
      height: 20px;
    }

    .checkbox-item.invalid .icon-container svg {
      fill: #f44336;
      width: 20px;
      height: 20px;
    }

    /* SD/LD Count Display */
    .sdld-count {
      margin-top: 10px;
      font-size: 1em;
      color: #333;
    }

    /* Search Field Container */
    .search-field-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Search Field with Clear Button */
    .search-field-with-clear {
      padding-right: 2.2em;
    }

    /* Clear Highlight Button */
    .clear-highlight-btn {
      position: absolute;
      right: 0.5em;
      background: none;
      border: none;
      font-size: 1.2em;
      color: #888;
      cursor: pointer;
      height: 55%;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    /* Arrow Icon Rotation */
    .arrow-icon-rotated {
      transition: transform 0.2s;
      transform: rotate(180deg);
    }

    /* Popup Background */
    .popup-background {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    /* Image Popup Content */
    .image-popup-content {
      background: #fff;
      border-radius: 12px;
      margin: 16px;
      width: calc(95vw - 32px);
      height: calc(95vh - 32px);
      display: flex;
      flex-direction: row;
      overflow: hidden;
    }

    /* Image Popup Sidebar */
    .image-popup-sidebar {
      flex: 0 0 30%;
      padding: 24px 12px 24px 24px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      background: #f7f7f7;
    }

    /* Image Link Input */
    .image-link-input {
      width: 100%;
      height: 100%;
      min-height: 0;
      resize: none;
      font-size: 1em;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      flex: 1 1 auto;
    }

    /* Clean Links Button */
    .clean-links-btn {
      margin-top: 8px;
      padding: 7px 16px;
      border-radius: 6px;
      border: none;
      background: #1a4fa0;
      color: #fff;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .clean-links-btn:hover {
      background: #163e7a;
    }

    .clean-links-btn:active {
      transform: scale(0.98);
    }

    /* Image Preview Container */
    .image-preview-container {
      flex: 1 1 70%;
      display: flex;
      flex-direction: column;
      background: #eaeaea;
      position: relative;
      min-width: 0;
      min-height: 0;
      overflow: hidden;
    }

    /* Image Display Area */
    .image-display-area {
      flex: 1 1 auto;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      min-width: 0;
      position: relative;
    }

    /* Carousel Button */
    .carousel-btn {
      position: absolute;
      z-index: 2;
      background: rgba(0, 0, 0, 0.3);
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #fff;
      font-size: 1.5em;
    }

    .carousel-btn.prev {
      left: 8px;
    }

    .carousel-btn.next {
      right: 8px;
    }

    /* Image Preview */
    .image-preview {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      object-fit: contain;
      background: #fff;
      display: block;
      margin: auto;
    }

    /* URL Opener Popup Content */
    .url-opener-popup-content {
      background: #fff;
      border-radius: 12px;
      margin: 16px;
      height: 50%;
      width: calc(90vw - 32px);
      max-width: 700px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      overflow: hidden;
    }

    /* URL Opener Input */
    .url-opener-input {
      width: calc(100% - 32px);
      height: 100%;
      margin: 0 16px 8px 16px;
      min-height: 80px;
      resize: none;
      font-size: 1em;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    /* URL Opener Buttons Container */
    .url-opener-buttons {
      display: flex;
      flex-direction: row;
      gap: 8px;
      justify-content: flex-end;
      margin: 0 16px 16px 16px;
    }

    /* URL Opener Button */
    .url-opener-btn {
      padding: 7px 16px;
      border-radius: 6px;
      border: none;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .url-opener-btn.clean {
      background: #8a8a8a;
      color: #fff;
    }

    .url-opener-btn.clean:hover {
      background: #6a6a6a;
    }

    .url-opener-btn.open {
      background: #1a4fa0;
      color: #fff;
    }

    .url-opener-btn.open:hover {
      background: #163e7a;
    }

    .url-opener-btn:active {
      transform: scale(0.98);
    }

    /* Thumbnail Image */
    .thumbnail-wrapper {
      position: relative;
      display: inline-block;
    }
    .thumbnail-img {
      height: 40px;
      width: auto;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
      cursor: pointer;
      border: 2px solid transparent;
      background: #fff;
      transition: border 0.15s;
    }
    .thumb-badge {
      position: absolute;
      top: 1px;
      right: 1px;
      min-width: 16px;
      height: 16px;
      background: #3d3d3d;
      color: #fff;
      font-size: 8px;
      font-weight: bold;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 4px rgba(0,0,0,0.13);
      z-index: 2;
      pointer-events: none;
      border: 2px solid #fff;
    }

    #thumbsRow .thumbnail-img.active {
      border: 2px solid #3e6cf4 !important;
      /* box-shadow: 0 0 0 2px #b3c6e7 !important; */
      background: #f0f6ff !important;
    }

    /* Status Text Colors */
    .status-fail {
      color: red;
    }

    .status-pass {
      color: #00ca00;
    }

    /* Popup Labels */
    .popup-label {
      font-size: 1em;
      margin-bottom: 8px;
      color: #222;
    }

    .popup-label.url-opener {
      margin: 16px 0 8px 16px;
    }

    .prism-editor {
      min-height: 120px;
      max-height: 100%;
      height: 100%;
      /* background: #eeeeee; */
      border: 2px solid #eeeeee;
      border-radius: 8px;
      padding: 8px;
      font-family: Georgia, Times, 'Times New Roman', serif;
      font-size: 1em;
      font-weight: 200;
      line-height: 1.5em;
      overflow-y: auto;
      resize: none;
      outline: none;
      color: #222;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0px;
    }

    .format-btns-div{
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-top: 8px;
    }

    .format-btns {
      height: 30px;
    }
    .prism-editor:focus {
      border: 2px solid #242424;
      background: #fafafa;
    }

    /* Override Prism.js tag color */
    .token.tag {
      color: #204cd1 !important;
    }

    .token.attr-name {
      color: #ff0a00 !important;
    }

    /* Invalid HTML tag highlight */
    .token.tag.invalid-tag {
      color: #eb0a00 !important;
      background: #fff0f0;
      border-radius: 2px;
      padding: 0 2px;
    }
  </style>
  <!-- Allow pop-ups and redirects by default (Chrome only) -->
  <meta http-equiv="Permissions-Policy" content="popups=(self), popups-redirect=(self)">
</head>

<body>

  <div class="container">
    <!-- First Div: Input Field -->
    <div class="flex-item">
      <h3>Enter your base data here</h3>
      <!-- Replace textarea with Prism.js editor -->
      <pre class="prism-editor" id="mainInput" contenteditable="true" spellcheck="false"></pre>
      <div class="format-btns-div">
        <div style="width: 100%;display: flex;flex-direction: row; gap: 8px; height: 30px;">
          <button id="wrapPBtn" class="format-btns" type="button" style="margin-left:6px;padding:3px 10px;border-radius:4px;border:none;background:#eaeaea;color:#222;font-size:0.95em;cursor:pointer;">p</button>
          <button id="wrapUlBtn" class="format-btns"type="button" style="margin-left:2px;padding:3px 10px;border-radius:4px;border:none;background:#eaeaea;color:#222;font-size:0.95em;cursor:pointer;">ul</button>
          <button id="wrapLiBtn" class="format-btns"type="button" style="margin-left:2px;padding:3px 10px;border-radius:4px;border:none;background:#eaeaea;color:#222;font-size:0.95em;cursor:pointer;">li</button>
        </div>
        <button id="cleanEditorBtn" type="button" style="padding:7px 16px;border-radius:6px;border:none;background:#1a4fa0;color:#fff;font-size:1em;cursor:pointer;transition:background 0.15s;">Clean</button>
      </div>  
    </div>
    <!-- Second Div: Formatted HTML Display -->
    <div class="flex-item">
      <h3>Formatted HTML Output:</h3>
      <div class="formatted-html" id="formattedOutput"></div>
      <div id="sdldCount" class="sdld-count"></div>
    </div>
    <!-- Third Div: Search/Highlight/Checkboxes -->
    <div class="flex-item-3" id="flexItem3">
      <h3>Enter the text to highlight</h3>
      <div class="search-field-container">
        <input class="search-field search-field-with-clear" id="highlightInput" type="text"
          placeholder="Type to highlight..." />
        <button id="clearHighlightBtn" type="button" class="clear-highlight-btn">&times;</button>
      </div>
      <div class="checkbox-list" id="checkboxList"></div>
      <input class="selected-field" id="selectedValues" type="text" placeholder="Selected values..." readonly />
      <button class="copy-btn" id="copyBtn" type="button">Copy</button>
    </div>
    <div class="flex-item-4">
      <div class="flex-arrow" id="flexArrow" title="Closed List">
        <span class="leftool-label">Closed List</span>
        <svg id="arrowIcon" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" style="rotate: 180deg;"
          xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#4f4f4f" viewBox="0 0 24 24"
          class="arrow-icon-rotated">
          <path fill-rule="evenodd"
            d="M10 4H4c-1.10457 0-2 .89543-2 2v12c0 1.1046.89543 2 2 2h6V4ZM4.37868 9.29289c-.39052.39053-.39052 1.02371 0 1.41421l1.29283 1.2928-1.29283 1.2929c-.39052.3905-.39052 1.0237 0 1.4142.39052.3905 1.02369.3905 1.41421 0l1.99994-2c.39053-.3905.39053-1.0236 0-1.4142L5.79289 9.29289c-.39052-.39052-1.02369-.39052-1.41421 0Z"
            clip-rule="evenodd" />
          <path d="M12 20h8c1.1046 0 2-.8954 2-2V6c0-1.10457-.8954-2-2-2h-8v16Z" />
        </svg>
      </div>
      <div class="flex-arrow" id="flexArrow" title="Image Viewer">
        <span class="leftool-label">Image Viewer</span>
        <!-- Never change this icon -->
        <svg id="imgPopup" class="w-6 h-6" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24"
          fill="#4f4f4f" viewBox="0 0 24 24" style="cursor: pointer;">
          <path fill-rule="evenodd" d="M13 10a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H14a1 1 0 0 1-1-1Z" clip-rule="evenodd"/>
  <path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12c0 .556-.227 1.06-.593 1.422A.999.999 0 0 1 20.5 20H4a2.002 2.002 0 0 1-2-2V6Zm6.892 12 3.833-5.356-3.99-4.322a1 1 0 0 0-1.549.097L4 12.879V6h16v9.95l-3.257-3.619a1 1 0 0 0-1.557.088L11.2 18H8.892Z" clip-rule="evenodd"/>
        </svg>
      </div>
      <div class="flex-arrow" id="urlOpenerArrow" title="Bulk URL">
        <span class="leftool-label">Bulk URL</span>
        <svg id="urlOpenerIcon" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#4f4f4f" viewBox="0 0 24 24">
          <path fill-rule="evenodd"
            d="M11.403 5H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6.403a3.01 3.01 0 0 1-1.743-1.612l-3.025 3.025A3 3 0 1 1 9.99 9.768l3.025-3.025A3.01 3.01 0 0 1 11.403 5Z"
            clip-rule="evenodd" />
          <path fill-rule="evenodd"
            d="M13.232 4a1 1 0 0 1 1-1H20a1 1 0 0 1 1 1v5.768a1 1 0 1 1-2 0V6.414l-6.182 6.182a1 1 0 0 1-1.414-1.414L17.586 5h-3.354a1 1 0 0 1-1-1Z"
            clip-rule="evenodd" />
        </svg>
      </div>
      <div class="flex-arrow" id="urlOpenerArrow" title="Unit Convertor">
        <span class="leftool-label">Unit Convertor</span>
        <svg id="unitConvertor" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" 
          xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
          <path stroke="#4f4f4f" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15v3c0 .5523.44772 1 1 1h10.5M3 15v-4m0 4h11M3 11V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5M3 11h18m0 0v1M8 11v8m4-8v8m4-8v2m1 4h2m0 0h2m-2 0v2m0-2v-2"/>
        </svg>
      </div>
    </div>
    <!-- Image Popup -->
    <div id="imagePopupBg" class="popup-background">
      <div id="imagePopupContent" class="image-popup-content">
        <div class="image-popup-sidebar">
          <label for='imgLinkInput' class="popup-label">Image Link(s)</label>
          <textarea id="imgLinkInput" class="image-link-input"
            placeholder="Paste image link(s), separated by commas..."></textarea>
          <button id="cleanLinksBtn" type="button" class="clean-links-btn">Clean Links</button>
        </div>
        <div class="image-preview-container">
          <div class="image-display-area">
            <button id="carouselPrev" class="carousel-btn prev">&#8592;</button>
            <img id="imgPreview" class="image-preview" src="" alt="Preview" />
            <button id="carouselNext" class="carousel-btn next">&#8594;</button>
          </div>
          <div id="thumbsRow"></div>
        </div>
      </div>
    </div>
    <!-- URL Opener Popup -->
    <div id="urlOpenerPopupBg" class="popup-background">
      <div id="urlOpenerPopupContent" class="url-opener-popup-content">
        <label for='urlOpenerInput' class="popup-label url-opener">Enter URL(s)</label>
        <textarea id="urlOpenerInput" class="url-opener-input"
          placeholder="Paste URLs, separated by commas or newlines..."></textarea>
        <div class="url-opener-buttons">
          <button id="urlOpenerCleanBtn" type="button" class="url-opener-btn clean">Clean</button>
          <button id="urlOpenerOpenBtn" type="button" class="url-opener-btn open">Open in Each Tab</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Prism.js library for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
  <script>
    // Helper: Parse input into array
    function parseInput(input) {
      return input
        .split(/\n/)
        .map(v => v.trim())
        .filter(v => v.length > 0);
    }

    // Helper: Escape HTML
    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, function (tag) {
        const chars = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        };
        return chars[tag] || tag;
      });
    }

    // Helper: Extract text nodes from HTML
    function extractTextNodesFromHTML(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      const textNodes = [];
      function traverse(node) {
        if (node.nodeType === 3) { // Text node
          textNodes.push(node.textContent.trim());
        } else if (node.nodeType === 1) { // Element node
          for (let child of node.childNodes) {
            traverse(child);
          }
        }
      }
      traverse(tempDiv);
      return textNodes;
    }

    // Helper: Extract all valid URLs (http/https) from a string, even if pasted together
    function extractAllUrls(raw) {
      // Add space before each "http" to separate concatenated URLs
      let processedRaw = raw.replace(/([^\s])https?:\/\//gi, '$1 http://');
      // Also handle https://
      processedRaw = processedRaw.replace(/([^\s])https?:\/\//gi, '$1 https://');

      // Now extract URLs from the processed string
      let urls = [];
      const urlRegex = /https?:\/\/[^\s,\n"'<>\[\](){}]+/gi;
      let match;

      while ((match = urlRegex.exec(processedRaw)) !== null) {
        let url = match[0];
        // Remove any brackets before or after the URL
        url = url.replace(/^[\[\({<]+|[\]\)}>]+$/g, '');
        // Clean up any trailing punctuation that might be part of the URL
        url = url.replace(/[.,;!?]+$/, '');
        urls.push(url);
      }

      return urls;
    }

    // Helper: Get plain text from Prism editor
    function getEditorText(editor) {
      // Get textContent, preserving line breaks
      return editor.innerText.replace(/\u200B/g, ''); // Remove zero-width spaces
    }

    // Helper: Save and restore caret position in contenteditable
    function saveCaretPosition(context) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return null;
      const range = selection.getRangeAt(0);
      const preSelectionRange = range.cloneRange();
      preSelectionRange.selectNodeContents(context);
      preSelectionRange.setEnd(range.startContainer, range.startOffset);
      const start = preSelectionRange.toString().length;
      return start;
    }

    function restoreCaretPosition(context, pos) {
      let nodeStack = [context], node, foundStart = false, charIndex = 0, range = document.createRange();
      range.setStart(context, 0);
      range.collapse(true);

      while (nodeStack.length && !foundStart) {
        node = nodeStack.pop();
        if (node.nodeType === 3) { // text node
          let nextCharIndex = charIndex + node.length;
          if (!foundStart && pos >= charIndex && pos <= nextCharIndex) {
            range.setStart(node, pos - charIndex);
            range.collapse(true);
            foundStart = true;
          }
          charIndex = nextCharIndex;
        } else {
          let i = node.childNodes.length;
          while (i--) {
            nodeStack.push(node.childNodes[i]);
          }
        }
      }
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    // Helper: Set editor content with syntax highlighting and invalid tag detection
    function setEditorContent(editor, value, caretPos = null) {
      // Use Prism to highlight as usual
      let html = Prism.highlight(value, Prism.languages.markup, 'markup');

      // Simple invalid tag detection (unclosed or unopened tags)
      // This is a basic check and may not cover all edge cases
      const openTags = [];
      const tagRegex = /<([a-zA-Z][\w:-]*)(\s[^>]*)?>|<\/([a-zA-Z][\w:-]*)>/g;
      let match;
      let tagPositions = [];
      while ((match = tagRegex.exec(value)) !== null) {
        if (match[1]) {
          // Opening tag
          openTags.push({ tag: match[1], index: match.index });
          tagPositions.push({ type: 'open', tag: match[1], index: match.index });
        } else if (match[3]) {
          // Closing tag
          let found = false;
          for (let i = openTags.length - 1; i >= 0; i--) {
            if (openTags[i].tag === match[3]) {
              openTags.splice(i, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            // Closing tag without open tag
            tagPositions.push({ type: 'close-invalid', tag: match[3], index: match.index });
          } else {
            tagPositions.push({ type: 'close', tag: match[3], index: match.index });
          }
        }
      }
      // Any tags left in openTags are unclosed
      openTags.forEach(t => {
        tagPositions.push({ type: 'open-invalid', tag: t.tag, index: t.index });
      });

      // Now, mark invalid tags in the highlighted HTML
      // We'll use a regex to find tags in the highlighted HTML and add the invalid-tag class
      // This is a best-effort approach for a live editor

      // Mark closing tags without open tag
      html = html.replace(/(<span class="token tag">)(<\/[a-zA-Z][\w:-]*>)(<\/span>)/g, (m, p1, p2, p3) => {
        if (/<\/([a-zA-Z][\w:-]*)>/.test(p2)) {
          const tag = p2.match(/<\/([a-zA-Z][\w:-]*)>/)[1];
          // If this tag is in tagPositions as close-invalid, mark as invalid
          if (tagPositions.some(tp => tp.type === 'close-invalid' && tp.tag === tag)) {
            return `<span class="token tag invalid-tag">${p2}</span>`;
          }
        }
        return m;
      });

      // Mark unclosed tags
      html = html.replace(/(<span class="token tag">)(<([a-zA-Z][\w:-]*)(\s[^>]*)?>)(<\/span>)/g, (m, p1, p2, p3, p4, p5) => {
        // If this tag is in tagPositions as open-invalid, mark as invalid
        if (tagPositions.some(tp => tp.type === 'open-invalid' && tp.tag === p3)) {
          return `<span class="token tag invalid-tag">${p2}</span>`;
        }
        return m;
      });

      editor.innerHTML = html;

      // Restore caret position if provided
      if (caretPos !== null) {
        restoreCaretPosition(editor, caretPos);
      }
    }

    // DOM Elements
    const mainInput = document.getElementById('mainInput');
    const formattedOutput = document.getElementById('formattedOutput');
    const highlightInput = document.getElementById('highlightInput');
    const checkboxList = document.getElementById('checkboxList');
    const selectedValues = document.getElementById('selectedValues');
    const copyBtn = document.getElementById('copyBtn');

    let values = [];
    let highlightText = '';
    let checkedSet = new Set();
    // State for single selected (for highlight)
    let singleSelected = '';

    // Render formatted HTML output and SD/LD counts
    function renderFormatted() {
      // If a value is selected in the checkbox-list, highlight it in the formatted-html
      let selectedHighlight = singleSelected;
      formattedOutput.innerHTML = values.map(val => {
        // If selectedHighlight is set, highlight it in the HTML (even if it's an HTML tag)
        if (selectedHighlight && val.toLowerCase().includes(selectedHighlight.toLowerCase())) {
          // Highlight all matches (but do not escape HTML, render as real HTML)
          const regex = new RegExp(`(${selectedHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          // Walk HTML nodes and highlight
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = val;
          function highlightNode(node) {
            if (node.nodeType === 3) { // Text node
              return node.nodeValue.replace(regex, '<span class="highlight">$1</span>');
            } else if (node.nodeType === 1) { // Element node
              let html = `<${node.tagName.toLowerCase()}`;
              for (let attr of node.attributes) {
                html += ` ${attr.name}="${attr.value}"`;
              }
              html += '>';
              for (let child of node.childNodes) {
                html += highlightNode(child);
              }
              html += `</${node.tagName.toLowerCase()}>`;
              return html;
            }
            return '';
          }
          let highlighted = '';
          for (let child of tempDiv.childNodes) {
            highlighted += highlightNode(child);
          }
          return `<div>${highlighted}</div>`;
        } else {
          // Render as real HTML
          return `<div>${val}</div>`;
        }
      }).join('');

      // SD/LD count logic
      const sdldDiv = document.getElementById('sdldCount');
      // Join all values as HTML for parsing
      const htmlString = values.join('\n');
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlString;
      // SD: count words in all <p> tags
      let sdCount = 0;
      const pTags = tempDiv.querySelectorAll('p');
      pTags.forEach(p => {
        // Count words in this <p>
        const words = p.textContent.trim().split(/\s+/).filter(Boolean);
        sdCount += words.length;
      });
      // LD: count <li> in all <ul>
      let ldCount = 0;
      const ulTags = tempDiv.querySelectorAll('ul');
      ulTags.forEach(ul => {
        ldCount += ul.querySelectorAll('li').length;
      });
      // SD color and fail
      let sdColor = sdCount < 55 ? 'red' : '#00ca00';
      let sdFail = sdCount < 55 ? ' <span class="status-fail">(Fail)</span>' : ' <span class="status-pass">(Pass)</span>';
      // LD color and fail
      let ldColor = ldCount < 3 ? 'red' : '#00ca00';
      let ldFail = ldCount < 3 ? ' <span class="status-fail">(Fail)</span>' : ' <span class="status-pass">(Pass)</span>';
      sdldDiv.innerHTML = `SD count: <span style="color:${sdColor}">${sdCount}</span>${sdFail}, LD count: <span style="color:${ldColor}">${ldCount}</span>${ldFail}`;
    }

    // Render checkbox list
    function renderCheckboxes() {
      // Show search terms from search-field in checkbox list
      let allCheckboxValues = [];
      if (highlightText.trim() !== '') {
        // Split search field by comma, colon, semicolon, pipe, trim, and filter non-empty
        allCheckboxValues = highlightText.split(/[,;|]/).map(v => v.trim()).filter(v => v.length > 0);
      }
      // Prepare array with validity and count
      let checkboxData = allCheckboxValues.map((val, idx) => {
        // Count actual occurrences of the search term in the HTML content
        let count = 0;
        values.forEach(v => {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = v;
          const textContent = tempDiv.textContent || tempDiv.innerText || '';
          const regex = new RegExp(val.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
          const matches = textContent.match(regex);
          if (matches) {
            count += matches.length;
          }
        });
        const isValid = count > 0;
        return { val, idx, checked: checkedSet.has(val), selected: singleSelected === val, isValid, count };
      });
      // Sort: valid first, then invalid
      checkboxData.sort((a, b) => {
        if (a.isValid === b.isValid) return 0;
        return a.isValid ? -1 : 1;
      });
      // Render
      checkboxList.innerHTML = checkboxData.map(item => {
        const checked = item.checked ? 'checked' : '';
        const selected = item.selected ? 'selected' : '';
        const validationClass = item.isValid ? 'valid' : 'invalid';
        // Show count next to span
        // Add icons only for valid items
        const iconSvg = item.isValid ?
          '<svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M13.729 5.575c1.304-1.074 3.27-.146 3.27 1.544v9.762c0 1.69-1.966 2.618-3.27 1.544l-5.927-4.881a2 2 0 0 1 0-3.088l5.927-4.88Z" clip-rule="evenodd"/></svg><svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M10.271 5.575C8.967 4.501 7 5.43 7 7.12v9.762c0 1.69 1.967 2.618 3.271 1.544l5.927-4.881a2 2 0 0 0 0-3.088l-5.927-4.88Z" clip-rule="evenodd"/></svg>' :
          '';
        const iconContainer = item.isValid ? `<div class="icon-container">${iconSvg}</div>` : '';
        return `<div class="checkbox-item ${selected} ${validationClass}" data-value="${escapeHtml(item.val)}"><div class="selection-area"><input type="checkbox" data-idx="${item.idx}" value="${escapeHtml(item.val)}" ${checked}><span>${escapeHtml(item.val)} <b>(${item.count})</b></span></div>${iconContainer}</div>`;
      }).join('');
    }

    // Update selected values field
    function updateSelectedField() {
      // Use pipeline separator instead of comma
      selectedValues.value = Array.from(checkedSet).join('|');
    }

    // Event: Main input change
    mainInput.addEventListener('input', () => {
      // Save caret position before re-highlighting
      let caretPos = saveCaretPosition(mainInput);

      // Get plain text from editor
      const text = getEditorText(mainInput);
      values = parseInput(text);
      checkedSet = new Set(values.filter(v => checkedSet.has(v)));
      renderFormatted();
      renderCheckboxes();
      updateSelectedField();
      singleSelected = '';

      // Fix caret position after pressing Enter (newline)
      // If the last character is a newline, move caret to end
      if (
        text.endsWith('\n') &&
        document.activeElement === mainInput
      ) {
        setEditorContent(mainInput, text);
        // Move caret to end
        const range = document.createRange();
        range.selectNodeContents(mainInput);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        // Re-highlight after input, restore caret
        setEditorContent(mainInput, text, caretPos);
      }
    });

    // Initial highlight for empty editor
    setEditorContent(mainInput, '');

    // Event: Highlight input change
    highlightInput.addEventListener('input', () => {
      highlightText = highlightInput.value;
      renderFormatted();
      renderCheckboxes(); // Update checkbox list when search text changes
      singleSelected = '';
    });

    // Event: Checkbox click (multi-select)
    checkboxList.addEventListener('click', (e) => {
      if (e.target && e.target.type === 'checkbox') {
        const input = e.target;
        const val = input.value;
        if (checkedSet.has(val)) {
          checkedSet.delete(val);
        } else {
          checkedSet.add(val);
        }
        renderCheckboxes();
        updateSelectedField();
        renderFormatted(); // Update formatted-html with highlight
      }
    });

    // Event: Selection area click (single select for highlight)
    checkboxList.addEventListener('click', (e) => {
      // Only trigger if clicking the selection area (not checkbox or arrows)
      if (e.target.type === 'checkbox' || e.target.closest('.icon-container')) return;
      const selectionArea = e.target.closest('.selection-area');
      if (!selectionArea) return;
      const item = selectionArea.closest('.checkbox-item');
      const val = item.getAttribute('data-value');
      const isValid = item.classList.contains('valid');
      if (singleSelected === val) {
        singleSelected = '';
      } else {
        singleSelected = val;
      }
      renderCheckboxes();
      renderFormatted();
      // If valid, focus the first highlight
      if (isValid && singleSelected === val) {
        setTimeout(() => {
          const highlights = formattedOutput.querySelectorAll('.highlight');
          if (highlights.length > 0) {
            highlights.forEach(h => h.classList.remove('focused'));
            highlights[0].classList.add('focused');
            highlights[0].scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
          }
        }, 0);
      }
    });

    // Navigation between highlighted items in formatted-html
    let currentHighlightIndex = -1;
    let allHighlights = [];
    let currentSelectedValue = '';

    checkboxList.addEventListener('click', (e) => {
      if (e.target.tagName === 'SVG' || e.target.closest('svg')) {
        const checkboxItem = e.target.closest('.checkbox-item');
        if (checkboxItem && checkboxItem.classList.contains('valid') && checkboxItem.classList.contains('selected')) {
          const searchValue = checkboxItem.getAttribute('data-value');

          // Only allow navigation if this is the currently selected item
          if (searchValue !== singleSelected) return;

          // Determine which button was clicked (right or left arrow)
          const svg = e.target.tagName === 'SVG' ? e.target : e.target.closest('svg');
          const isRightButton = svg === checkboxItem.querySelector('.icon-container svg:first-child');

          // Find all highlights for this search value
          allHighlights = Array.from(formattedOutput.querySelectorAll('.highlight'));

          if (allHighlights.length > 0) {
            // Remove previous focus
            allHighlights.forEach(h => h.classList.remove('focused'));

            if (isRightButton) {
              // Go to previous highlight (left arrow = previous)
              currentHighlightIndex = (currentHighlightIndex - 1 + allHighlights.length) % allHighlights.length;
            } else {
              // Go to next highlight (right arrow = next)
              currentHighlightIndex = (currentHighlightIndex + 1) % allHighlights.length;
            }

            // Focus on current highlight
            const currentHighlight = allHighlights[currentHighlightIndex];
            if (currentHighlight) {
              currentHighlight.classList.add('focused');

              // Scroll to the highlighted element
              currentHighlight.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'center'
              });
            }
          }
        }
      }
    });

    // Reset highlight focus when search changes
    highlightInput.addEventListener('input', () => {
      currentHighlightIndex = -1;
      allHighlights = [];
      currentSelectedValue = '';
      // Remove all focused highlights
      formattedOutput.querySelectorAll('.highlight.focused').forEach(h => h.classList.remove('focused'));
    });

    // Copy button logic
    copyBtn.addEventListener('click', () => {
      if (selectedValues.value) {
        navigator.clipboard.writeText(selectedValues.value);
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyBtn.textContent = 'Copy';
        }, 1200);
      }
    });

    // Arrow toggle logic
    const flexItem3 = document.getElementById('flexItem3');
    const flexArrow = document.getElementById('flexArrow');
    const arrowIcon = document.getElementById('arrowIcon');
    let flexItem3Visible = true;

    // Ensure only one flexArrow and arrowIcon are used
    flexArrow.addEventListener('click', () => {
      flexItem3Visible = !flexItem3Visible;
      if (flexItem3Visible) {
        flexItem3.style.display = '';
        arrowIcon.style.transform = 'rotate(180deg)';
        flexArrow.classList.add('selected');
      } else {
        flexItem3.style.display = 'none';
        arrowIcon.style.transform = 'rotate(0deg)';
        flexArrow.classList.remove('selected');
      }
    });

    // Set default selected state and icon rotation
    flexArrow.classList.add('selected');
    arrowIcon.style.transform = 'rotate(180deg)';

    // Image Popup logic
    const imgPopup = document.getElementById('imgPopup');
    const imagePopupBg = document.getElementById('imagePopupBg');
    const imgLinkInput = document.getElementById('imgLinkInput');
    const imgPreview = document.getElementById('imgPreview');
    const carouselPrev = document.getElementById('carouselPrev');
    const carouselNext = document.getElementById('carouselNext');
    const thumbsRow = document.getElementById('thumbsRow');
    let imageLinks = [];
    let currentImgIdx = 0;
    let popupOpen = false;

    // Function to toggle image popup
    function toggleImagePopup() {
      if (!popupOpen) {
        imagePopupBg.style.display = 'flex';
        popupOpen = true;
        // imgLinkInput.focus(); // Removed to prevent auto-focus and accidental 'e' input
        // Restore the links if they exist
        if (imageLinks.length > 0) {
          imgLinkInput.value = imageLinks.join(', ');
          updateImagePreview();
        }
      } else {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    }

    imgPopup.style.cursor = 'pointer';
    imgPopup.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent any parent logic
      toggleImagePopup();
    });

    // Keyboard shortcuts for arrowIcon (Q), imgPopup (W), and urlOpener (E)
    document.addEventListener('keydown', (e) => {
      // Prevent shortcuts if typing in prism-editor
      const active = document.activeElement;
      if (
        active === mainInput ||
        (active && active.classList && active.classList.contains('prism-editor'))
      ) {
        return;
      }
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === 'q' || e.key === 'Q') {
        flexArrow.click();
      }
      if (e.key === 'w' || e.key === 'W') {
        toggleImagePopup();
      }
      if (e.key === 'e' || e.key === 'E') {
        if (urlOpenerPopupBg.style.display === 'flex') {
          urlOpenerPopupBg.style.display = 'none';
          urlOpenerInput.value = '';
        } else {
          urlOpenerPopupBg.style.display = 'flex';
        }
      }
    });

    // Image preview hover zoom and mouse move functionality
    let isZoomed = false;
    let isDragging = false;
    let startX, startY, translateX = 0, translateY = 0, scale = 1;
    const zoomScale = 1.5; // Zoom scale factor

    // Get the container of imgPreview
    const imgContainer = imgPreview.parentElement;

    imgContainer.addEventListener('mouseover', () => {
      if (!isZoomed) {
        imgPreview.style.transform = `scale(${zoomScale})`;
        isZoomed = true;
      }
    });

    imgContainer.addEventListener('mouseout', () => {
      if (isZoomed && !isDragging) {
        imgPreview.style.transform = 'scale(1)';
        isZoomed = false;
        translateX = 0;
        translateY = 0;
        imgPreview.style.transformOrigin = 'center';
      }
    });

    imgContainer.addEventListener('mousemove', (e) => {
      if (isZoomed) {
        const rect = imgContainer.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        imgPreview.style.transformOrigin = `${x}% ${y}%`;
      }
    });

    imgPreview.addEventListener('mousedown', (e) => {
      if (isZoomed) {
        isDragging = true;
        startX = e.clientX - translateX;
        startY = e.clientY - translateY;
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging && isZoomed) {
        translateX = e.clientX - startX;
        translateY = e.clientY - startY;
        const rect = imgContainer.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        imgPreview.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomScale})`;
        imgPreview.style.transformOrigin = `${x}% ${y}%`;
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Reset zoom when changing images
    function resetImageZoom() {
      isZoomed = false;
      isDragging = false;
      translateX = 0;
      translateY = 0;
      imgPreview.style.transform = 'scale(1)';
      imgPreview.style.transformOrigin = 'center';
    }

    // Live update image preview and carousel
    function updateImagePreview() {
      // Split by comma or newline, trim, filter empty
      imageLinks = imgLinkInput.value.split(/[\s,\n]+/).map(v => v.trim()).filter(v => v.length > 0);
      if (imageLinks.length === 0) {
        imgPreview.src = '';
        carouselPrev.style.display = 'none';
        carouselNext.style.display = 'none';
        thumbsRow.innerHTML = '';
        resetImageZoom();
        return;
      }
      if (currentImgIdx >= imageLinks.length) currentImgIdx = 0;
      imgPreview.src = imageLinks[currentImgIdx];
      resetImageZoom();
      if (imageLinks.length > 1) {
        carouselPrev.style.display = 'flex';
        carouselNext.style.display = 'flex';
      } else {
        carouselPrev.style.display = 'none';
        carouselNext.style.display = 'none';
      }
      // Render all thumbnails
      thumbsRow.innerHTML = imageLinks.map((src, idx) =>
        `<div class="thumbnail-wrapper" style="position:relative;display:inline-block;">
          <img src="${src}" data-idx="${idx}" class="thumbnail-img ${idx === currentImgIdx ? 'active' : ''}">
          <span class="thumb-badge">${idx + 1}</span>
        </div>`
      ).join('');
      // Scroll active thumbnail into view
      const activeThumb = thumbsRow.querySelector('.thumbnail-img.active');
      if (activeThumb) {
        activeThumb.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
      }
    }

    // Thumbnail click logic
    thumbsRow.addEventListener('click', (e) => {
      if (e.target && e.target.tagName === 'IMG' && e.target.hasAttribute('data-idx')) {
        const idx = parseInt(e.target.getAttribute('data-idx'));
        if (!isNaN(idx)) {
          currentImgIdx = idx;
          updateImagePreview();
        }
      }
    });

    imgLinkInput.addEventListener('input', () => {
      currentImgIdx = 0;
      updateImagePreview();
    });

    carouselPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      if (imageLinks.length > 1) {
        currentImgIdx = (currentImgIdx - 1 + imageLinks.length) % imageLinks.length;
        updateImagePreview();
      }
    });
    carouselNext.addEventListener('click', (e) => {
      e.stopPropagation();
      if (imageLinks.length > 1) {
        currentImgIdx = (currentImgIdx + 1) % imageLinks.length;
        updateImagePreview();
      }
    });

    // Close popup on bg click (not content)
    imagePopupBg.addEventListener('click', (e) => {
      if (e.target === imagePopupBg) {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    });

    // Close popup on ESC
    document.addEventListener('keydown', (e) => {
      if (popupOpen && e.key === 'Escape') {
        imagePopupBg.style.display = 'none';
        popupOpen = false;
        imgPreview.src = '';
        // Don't clear the links, just hide the popup
        // imageLinks and currentImgIdx are preserved
      }
    });

    // Keyboard navigation for image popup carousel
    document.addEventListener('keydown', (e) => {
      if (popupOpen && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        if (imageLinks.length > 1) {
          if (e.key === 'ArrowLeft') {
            currentImgIdx = (currentImgIdx - 1 + imageLinks.length) % imageLinks.length;
            updateImagePreview();
          } else if (e.key === 'ArrowRight') {
            currentImgIdx = (currentImgIdx + 1) % imageLinks.length;
            updateImagePreview();
          }
        }
      }
    });

    // Clean links button logic
    const cleanLinksBtn = document.getElementById('cleanLinksBtn');
    cleanLinksBtn.addEventListener('click', () => {
      // Use the same URL extraction logic as URL opener
      const cleaned = extractAllUrls(imgLinkInput.value);
      imgLinkInput.value = cleaned.join('\n');
      updateImagePreview();
    });

    // URL Opener logic
    const urlOpenerArrow = document.getElementById('urlOpenerArrow');
    const urlOpenerPopupBg = document.getElementById('urlOpenerPopupBg');
    const urlOpenerInput = document.getElementById('urlOpenerInput');
    const urlOpenerCleanBtn = document.getElementById('urlOpenerCleanBtn');
    const urlOpenerOpenBtn = document.getElementById('urlOpenerOpenBtn');

    urlOpenerArrow.addEventListener('click', () => {
      urlOpenerPopupBg.style.display = 'flex';
      urlOpenerInput.focus();
    });
    urlOpenerPopupBg.addEventListener('click', (e) => {
      if (e.target === urlOpenerPopupBg) {
        urlOpenerPopupBg.style.display = 'none';
        urlOpenerInput.value = '';
      }
    });
    document.addEventListener('keydown', (e) => {
      if (urlOpenerPopupBg.style.display === 'flex' && e.key === 'Escape') {
        urlOpenerPopupBg.style.display = 'none';
        urlOpenerInput.value = '';
      }
    });
    urlOpenerCleanBtn.addEventListener('click', () => {
      // Extract all valid URLs and join with a space
      const cleaned = extractAllUrls(urlOpenerInput.value);
      urlOpenerInput.value = cleaned.join('\n');
    });
    urlOpenerOpenBtn.addEventListener('click', () => {
      // Open all valid URLs in new tabs (synchronously, like bulk url opener)
      const urls = extractAllUrls(urlOpenerInput.value);
      urls.forEach(url => {
        window.open(url, '_blank');
      });
    });

    // Initial render
    renderFormatted();
    renderCheckboxes();
    updateSelectedField();
    updateImagePreview();

    // Escape key handler for input-field
    mainInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // Clear selection in contenteditable
        window.getSelection().removeAllRanges();
        mainInput.blur();
      }
    });

    // Handle paste events to clean up Excel data
    mainInput.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      const content = getEditorText(mainInput);
      const cursorPos = getTextOffset(mainInput, range.startContainer, range.startOffset);
      const cleanedText = text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .join('\n');

      let before, after;
      if (!selection.isCollapsed) {
        // There is a selection, so replace the selected text
        const start = getTextOffset(mainInput, range.startContainer, range.startOffset);
        const end = getTextOffset(mainInput, range.endContainer, range.endOffset);
        before = content.substring(0, start);
        after = content.substring(end);
      } else {
        // No selection, just insert at cursor
        before = content.substring(0, cursorPos);
        after = content.substring(cursorPos);
      }
      const newContent = before + cleanedText + after;
      setEditorContent(mainInput, newContent);
      const newCursorPos = before.length + cleanedText.length;
      restoreCaretPosition(mainInput, newCursorPos);
      mainInput.dispatchEvent(new Event('input'));
    });



    // Only focus textarea if user clicks inside it
    urlOpenerInput.addEventListener('mousedown', function (e) {
      if (document.activeElement !== urlOpenerInput) {
        urlOpenerInput.focus();
      }
    });

    // Fix: Clear Highlight Button logic
    const clearHighlightBtn = document.getElementById('clearHighlightBtn');
    clearHighlightBtn.addEventListener('click', () => {
      highlightInput.value = '';
      highlightText = '';
      singleSelected = '';
      checkedSet.clear(); // Clear all selected values
      selectedValues.value = ''; // Clear the selected values field
      renderFormatted();
      renderCheckboxes();
      updateSelectedField();
      // Remove all focused highlights
      formattedOutput.querySelectorAll('.highlight.focused').forEach(h => h.classList.remove('focused'));
    });

    // Clean button logic for prism-editor
    const cleanEditorBtn = document.getElementById('cleanEditorBtn');
    cleanEditorBtn.addEventListener('click', () => {
      // Get current editor text
      let text = getEditorText(mainInput);

      // Replace HTML coded characters with their actual character
      // Handles &amp;, &lt;, &gt;, &quot;, &#39;, and numeric codes
      text = text.replace(/&amp;/g, '&')
               .replace(/&lt;/g, '<')
               .replace(/&gt;/g, '>')
               .replace(/&quot;/g, '"')
               .replace(/&#39;/g, "'")
               .replace(/&#(\d+);/g, (m, code) => String.fromCharCode(code));

      // Set cleaned text back to editor with highlighting
      setEditorContent(mainInput, text);

      // Trigger input event to update everything else
      mainInput.dispatchEvent(new Event('input'));
    });

    // Helper: Wrap selected text in Prism editor
    function wrapSelection(tag) {
      const editor = mainInput;
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      
      const range = sel.getRangeAt(0);
      if (!editor.contains(range.commonAncestorContainer)) return;
      
      // Get the full editor content and selection positions
      const content = getEditorText(editor);
      const start = getTextOffset(editor, range.startContainer, range.startOffset);
      const end = getTextOffset(editor, range.endContainer, range.endOffset);
      
      // Create the wrapped content
      const before = content.substring(0, start);
      const selected = content.substring(start, end);
      const after = content.substring(end);
      const wrapped = before + `<${tag}>` + selected + `</${tag}>` + after;
      
      // Update editor content
      setEditorContent(editor, wrapped);
      
      // Update highlighting and trigger change event
      editor.dispatchEvent(new Event('input'));
      editor.focus();
    }

    // Helper: Get text offset for a node and position
    function getTextOffset(root, node, offset) {
      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      let totalOffset = 0;
      let currentNode = walker.nextNode();
      
      while (currentNode) {
        if (currentNode === node) {
          return totalOffset + offset;
        }
        totalOffset += currentNode.length;
        currentNode = walker.nextNode();
      }
      
      return totalOffset;
    }

    // Add event listeners for wrap buttons
    document.getElementById('wrapPBtn').addEventListener('click', () => wrapSelection('p'));
    document.getElementById('wrapUlBtn').addEventListener('click', () => wrapSelection('ul'));
    document.getElementById('wrapLiBtn').addEventListener('click', () => wrapSelection('li'));
  </script>
  <!-- Unit Converter Popup Modal -->
  <div id="unitConverterPopup" class="unit-converter-popup">
    <div class="unit-converter-modal">
      <div class="unit-converter-header">
        <span style="font-size: 2rem; font-weight: 600;">Convert Units</span>
        <span id="closeUnitConverter" style="font-size: 2rem; cursor: pointer; color: #888;">&times;</span>
      </div>
      <div class="unit-tabs">
  <button class="unit-tab active">Length</button>
  <button class="unit-tab">Weight</button>
  <button class="unit-tab">Volume</button>
  <!-- <button class="unit-tab">Speed</button>
  <button class="unit-tab">Area</button> -->
  <button class="unit-tab">Temperature</button>
</div>
<div class="unit-converter-main">
  <div class="unit-col">
    <div class="unit-label">Select UOM</div>
    <input class="unit-input" placeholder="Enter Value" id="fromValue" />
    <div class="unit-btn-row" id="fromUnitBtns">
      <!-- Dynamic buttons will be injected here -->
    </div>
  </div>
  <div class="unit-converter-arrow custom-arrow">
    <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 24 24">
      <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m16 10 3-3m0 0-3-3m3 3H5v3m3 4-3 3m0 0 3 3m-3-3h14v-3"/>
    </svg>
  </div>
  <div class="unit-col">
    <div class="unit-label">Converted UOM</div>
    <input class="unit-input" placeholder="Enter Value" id="toValue" readonly />
    <div class="unit-btn-row" id="toUnitBtns">
      <!-- Dynamic buttons will be injected here -->
    </div>
  </div>
</div>

    </div>
  </div>

  <style>
    .unit-converter-popup {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(20,20,20,0.7);
      justify-content: center;
      align-items: center;
    }
    .unit-converter-popup.active { display: flex; }
    .unit-converter-modal {
      background: #ffffff;
      border-radius: 12px;
      padding: 2.5vw 2vw;
      width: 98vw;
      max-width: 1200px;
      box-shadow: 0 6px 32px rgba(0,0,0,0.18);
      box-sizing: border-box;
    }
    .unit-converter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 1.5vw;
      color: #1f1f1f;
    }
    .unit-converter-main {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 2vw;
      background: #fff;
      border-radius: 12px;
      padding: 2vw 0;
      box-sizing: border-box;
      width: 100%;
      align-items: flex-start;
      justify-content: space-between;
    }
    .unit-col {
      flex: 1 1 280px;
      display: flex;
      flex-direction: column;
      gap: 1vw;
      min-width: 220px;
      /* max-width: 350px; */
      box-sizing: border-box;
      align-items: stretch;
    }
    .unit-converter-arrow.custom-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 56px;
      padding: 0 1vw;
      margin-top: 60px;
    }
    .unit-converter-arrow.custom-arrow svg {
      width: 2.5em;
      height: 2.5em;
      color: #76809b;
      display: block;
    }

    .unit-converter-side {
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      gap: 1.2vw;
      min-width: 240px;
      box-sizing: border-box;
      padding: 0 0.5vw;
    }
    .unit-tabs {
      display: flex;
      gap: 0.6vw;
      padding-bottom: 0.5vw;
      flex-wrap: wrap;
    }
    .unit-tab {
      background: #f3f3f3;
      border: none;
      padding: 0.5em 1.5em;
      border-radius: 8px;
      font-size: 16px;
      color: #222;
      cursor: pointer;
      transition: background 0.16s;
      font-weight: 400;
      box-sizing: border-box;
    }
    .unit-tab.active, .unit-tab:focus {
      background: #204cd1;
      color: #fff;
      font-weight: 400;
    }
    .unit-label {
      font-size: 1.1em;
      color: #444;
      padding-bottom: 0.3vw;
      font-weight: 500;
    }
    .unit-input {
      width: 100%;
      padding: 1.3em 1em;
      border-radius: 10px;
      border: none;
      background: #ededed;
      font-size: 1.6em;
      color: #555;
      box-sizing: border-box;
    }
    .unit-btn-row {
      display: flex;
      gap: 0.7vw;
      padding-top: 0.5vw;
      flex-wrap: wrap;
      width: 100%;
    }
    .unit-btn {
      background: #ededed;
      border: none;
      padding: 0.5em 1.5em;
      border-radius: 8px;
      color: #222;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.18s, color 0.18s;
      font-weight: 400;
      box-sizing: border-box;
    }
    .unit-btn.active, .unit-btn:focus {
      background: #204cd1;
      color: #fff;
      font-weight: 400;
    }
    .unit-converter-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 1vw;
      min-width: 40px;
    }
    @media (max-width: 900px) {
      .unit-converter-modal { width: 99vw; min-width: unset; padding: 2vw 0.5vw; }
      .unit-converter-main { flex-direction: column; gap: 2vw; padding: 2vw 0.5vw; align-items: stretch; }
      .unit-col { max-width: 100%; min-width: 0; }
      .unit-converter-arrow.custom-arrow { min-width: 40px; padding: 1vw 0; }
    }
    @media (max-width: 600px) {
      .unit-converter-modal { padding: 2vw 0.2vw; }
      .unit-converter-main { gap: 3vw; padding: 2vw 0.2vw; }
      .unit-tabs, .unit-btn-row { gap: 2vw; }
      .unit-input { font-size: 1.15em; padding: 0.9em 0.7em; }
      .unit-converter-arrow.custom-arrow svg { width: 2em; height: 2em; }
    }
  </style>
  <script>
    // Popup open/close logic
    document.getElementById('unitConvertor').onclick = function() {
      document.getElementById('unitConverterPopup').classList.add('active');
    };
    document.getElementById('closeUnitConverter').onclick = function() {
      document.getElementById('unitConverterPopup').classList.remove('active');
    };
    document.getElementById('unitConverterPopup').onclick = function(e) {
      if(e.target === this) this.classList.remove('active');
    };
    // --- Dynamic Unit Buttons Logic ---
const unitCategories = {
  Length: [
    'Kilometre', 'Metre', 'Centimetre', 'Millimetre', 'Micrometre', 'Nanometre',
    'Mile', 'Yard', 'Foot', 'Inch', 'Nautical mile'
  ],
  Weight: [
    'Kilogram', 'Gram', 'Milligram', 'Microgram', 'Imperial ton', 'US ton', 'Stone', 'Pound', 'Ounce'
  ],
  Volume: [
    'US liquid gallon', 'US liquid quart', 'US liquid pint', 'US legal cup', 'US fluid ounce', 'US tablespoon', 'US teaspoon',
    'Cubic meter', 'Liter', 'Milliliter', 'Imperial gallon', 'Imperial quart', 'Cl', 'Imperial pint', 'Imperial cup',
    'Imperial fluid ounce', 'Imperial tablespoon', 'Imperial teaspoon', 'Cubic foot', 'Cubic inch'
  ],
  Temperature: [
    'Degree Celsius', 'Fahrenheit', 'Kelvin'
  ]
};
let selectedCategory = 'Length';
let fromUnit = unitCategories[selectedCategory][2]; // Default to 'Metre'
let toUnit = unitCategories[selectedCategory][3];   // Default to 'Centimetre'

function renderUnitButtons() {
  const units = unitCategories[selectedCategory];
  const fromBtns = units.map(unit => `<button class="unit-btn${unit === fromUnit ? ' active' : ''}" data-unit="${unit}">${unit}</button>`).join('');
  const toBtns = units.map(unit => `<button class="unit-btn${unit === toUnit ? ' active' : ''}" data-unit="${unit}">${unit}</button>`).join('');
  document.getElementById('fromUnitBtns').innerHTML = fromBtns;
  document.getElementById('toUnitBtns').innerHTML = toBtns;
}

window.addEventListener('DOMContentLoaded', function() {
  Array.from(document.querySelectorAll('.unit-tab')).forEach(tab => {
    tab.addEventListener('click', function() {
      document.querySelectorAll('.unit-tab').forEach(t => t.classList.remove('active'));
      this.classList.add('active');
      selectedCategory = this.textContent.trim();
      // Set defaults for the new category
      if (unitCategories[selectedCategory]) {
        fromUnit = unitCategories[selectedCategory][0];
        toUnit = unitCategories[selectedCategory][1] || unitCategories[selectedCategory][0];
      }
      renderUnitButtons();
    });
  });
  // Initial render
  renderUnitButtons();
  document.getElementById('fromUnitBtns').addEventListener('click', e => handleUnitBtnClick(e, 'from'));
  document.getElementById('toUnitBtns').addEventListener('click', e => handleUnitBtnClick(e, 'to'));
});
function handleUnitBtnClick(e, type) {
  if (e.target.classList.contains('unit-btn')) {
    if (type === 'from') {
      fromUnit = e.target.textContent.trim();
      renderUnitButtons();
    } else if (type === 'to') {
      toUnit = e.target.textContent.trim();
      renderUnitButtons();
    }
  }
}
// --- End Dynamic Unit Buttons Logic ---

// --- Conversion Logic ---
const lengthUnitToMeter = {
  'Kilometre': 1000,
  'Metre': 1,
  'Centimetre': 0.01,
  'Millimetre': 0.001,
  'Micrometre': 0.000001,
  'Nanometre': 0.000000001,
  'Mile': 1609.344,
  'Yard': 0.9144,
  'Foot': 0.3048,
  'Inch': 0.0254,
  'Nautical mile': 1852
};
const weightUnitToKg = {
  'Kilogram': 1,
  'Gram': 0.001,
  'Milligram': 0.000001,
  'Microgram': 0.000000001,
  'Imperial ton': 1016.0469088,
  'US ton': 907.18474,
  'Stone': 6.35029318,
  'Pound': 0.45359237,
  'Ounce': 0.0283495231
};

function convertLength(value, from, to) {
  if (!(from in lengthUnitToMeter) || !(to in lengthUnitToMeter)) return '';
  const meters = parseFloat(value) * lengthUnitToMeter[from];
  return meters / lengthUnitToMeter[to];
}
function convertWeight(value, from, to) {
  if (!(from in weightUnitToKg) || !(to in weightUnitToKg)) return '';
  const kg = parseFloat(value) * weightUnitToKg[from];
  return kg / weightUnitToKg[to];
}

function updateConversion() {
  const inputVal = document.getElementById('fromValue').value;
  if (inputVal === '' || isNaN(Number(inputVal))) {
    document.getElementById('toValue').value = '';
    return;
  }
  let result = '';
  if (selectedCategory === 'Length') {
    result = convertLength(inputVal, fromUnit, toUnit);
  } else if (selectedCategory === 'Weight') {
    result = convertWeight(inputVal, fromUnit, toUnit);
  }
  document.getElementById('toValue').value = isNaN(result) ? '' : result;
}

// Listen for changes
window.addEventListener('DOMContentLoaded', function() {
  document.getElementById('fromValue').addEventListener('input', updateConversion);
});
// Patch renderUnitButtons to call updateConversion after re-render
const origRenderUnitButtons = renderUnitButtons;
renderUnitButtons = function() {
  origRenderUnitButtons();
  updateConversion();
};
const volumeUnitToLiter = {
  'US liquid gallon': 3.785411784,
  'US liquid quart': 0.946352946,
  'US liquid pint': 0.473176473,
  'US legal cup': 0.24,
  'US fluid ounce': 0.0295735295625,
  'US tablespoon': 0.01478676478125,
  'US teaspoon': 0.00492892159375,
  'Cubic meter': 1000,
  'Liter': 1,
  'Milliliter': 0.001,
  'Imperial gallon': 4.54609,
  'Imperial quart': 1.1365225,
  'Cl': 0.01,
  'Imperial pint': 0.56826125,
  'Imperial cup': 0.284130625,
  'Imperial fluid ounce': 0.0284130625,
  'Imperial tablespoon': 0.0177582,
  'Imperial teaspoon': 0.00591939,
  'Cubic foot': 28.316846592,
  'Cubic inch': 0.016387064
};

function convertVolume(value, from, to) {
  if (!(from in volumeUnitToLiter) || !(to in volumeUnitToLiter)) return '';
  const liters = parseFloat(value) * volumeUnitToLiter[from];
  return liters / volumeUnitToLiter[to];
}

// Update updateConversion to support Volume
function convertTemperature(value, from, to) {
  value = parseFloat(value);
  if (from === to) return value;
  // Convert from -> Celsius
  let celsius;
  if (from === 'Degree Celsius') {
    celsius = value;
  } else if (from === 'Fahrenheit') {
    celsius = (value - 32) * 5/9;
  } else if (from === 'Kelvin') {
    celsius = value - 273.15;
  } else {
    return '';
  }
  // Convert Celsius -> to
  if (to === 'Degree Celsius') return celsius;
  if (to === 'Fahrenheit') return celsius * 9/5 + 32;
  if (to === 'Kelvin') return celsius + 273.15;
  return '';
}

const oldUpdateConversion = updateConversion;
updateConversion = function() {
  const inputVal = document.getElementById('fromValue').value;
  if (inputVal === '' || isNaN(Number(inputVal))) {
    document.getElementById('toValue').value = '';
    return;
  }
  let result = '';
  if (selectedCategory === 'Length') {
    result = convertLength(inputVal, fromUnit, toUnit);
  } else if (selectedCategory === 'Weight') {
    result = convertWeight(inputVal, fromUnit, toUnit);
  } else if (selectedCategory === 'Volume') {
    result = convertVolume(inputVal, fromUnit, toUnit);
  } else if (selectedCategory === 'Temperature') {
    result = convertTemperature(inputVal, fromUnit, toUnit);
  }
  document.getElementById('toValue').value = isNaN(result) ? '' : result;
};
// --- End Conversion Logic ---

// Keyboard shortcut: 'S' key toggles popup
    document.addEventListener('keydown', function(e) {
      if (e.key === 's' || e.key === 'S') {
        const popup = document.getElementById('unitConverterPopup');
        popup.classList.toggle('active');
      }
    });
    // Tab logic (visual only)
    document.querySelectorAll('.unit-tabs').forEach(tabRow => {
      tabRow.addEventListener('click', function(e) {
        if(e.target.classList.contains('unit-tab')) {
          tabRow.querySelectorAll('.unit-tab').forEach(btn=>btn.classList.remove('active'));
          e.target.classList.add('active');
        }
      });
    });
    // Unit button logic (visual only)
    document.querySelectorAll('.unit-btn-row').forEach(btnRow => {
      btnRow.addEventListener('click', function(e) {
        if(e.target.classList.contains('unit-btn')) {
          btnRow.querySelectorAll('.unit-btn').forEach(btn=>btn.classList.remove('active'));
          e.target.classList.add('active');
        }
      });
    });
  </script>
</body>

</html>
